##### 常见缓存淘汰策略

- 先进先出策略 FIFO（First In，First Out）

- 最少使用策略 LFU（Least Frequently Used）

- 最近最少使用策略 LRU（Least Recently Used）

总是混淆 `LFU` 和 `LRU`，这里需要做个区别。

**LFU** 只是按使用次数为标准，比如：缓存A使用了5次，缓存B使用了3次，缓存C使用了10次，那么按照这种策略就需要淘汰B。乍看没问题，但是这个策略忽略了使用热度的问题。如果缓存C的10次是一个星期前使用的，而缓存B的3次是今天使用的，那么毫无疑问，接下来缓存B使用的频次应该是大于C的，所以合理的淘汰策略应该是 **LRU**。

**LRU** 侧重于时效性。越是最近使用的缓存，越不会被淘汰。

##### 数组和链表

数组需要连续的内存空间，而链表是通过指针将零散的内存空间”串联“起来。

##### NULL 和 void *

前者是一个指针值，后者是一个指针类型，这点不要混淆了。

##### 链表分类

**单链表**

尾结点的指针指向 NULL。

单纯插入和删除操作的时间复杂度是O(1)。

删除值等于给定值的结点对应的链表操作的总时间复杂度为 O(n)。

随机访问的时间复杂度是O(n)。

**循环链表**

尾结点的指针指向链表的头结点。

**双向链表**

每个结点不止有一个后继指针 next 指向后面的结点，还有一个前驱指针 prev 指向前面的结点。

对于单链表的优势体现在这些操作上：

- 删除给定指针指向的结点

- 在给定指针指向的结点前插入新结点

- 有序链表的查询

**双向循环链表**

##### 链表的缺点

链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片。

##### 基于单链表实现 LRU 算法





