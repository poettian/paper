#### 文件流

**数据在文件和内存之间传递的过程叫做文件流，类似水从一个地方流动到另一个地方。数据从文件复制到内存的过程叫做输入流，从内存保存到文件的过程叫做输出流。**

**我们把数据在数据源和程序（内存）之间传递的过程叫做数据流(Data Stream)。相应的，数据从数据源到程序（内存）的过程叫做输入流(Input Stream)，从程序（内存）到数据源的过程叫做输出流(Output Stream)。**

**我们可以说，打开文件就是打开了一个流。**

##### 打开文件

1) 文件打开方式由r、w、a、t、b、+ 六个字符拼成，各字符的含义是：

- r(read)：读
- w(write)：写
- a(append)：追加
- t(text)：文本文件，可省略不写
- b(banary)：二进制文件
- +：读和写


2) 如果没有“b”字符，文件以文本方式打开。

3) 凡用“r”打开一个文件时，该文件必须已经存在。

4) 在打开一个文件时，如果出错，fopen将返回一个空指针值NULL。

5) 把一个文本文件读入内存时，要将ASCII码转换成二进制码，而把文件以文本方式写入磁盘时，也要把二进制码转换成ASCII码，因此文本文件的读写要花费较多的转换时间。对二进制文件的读写不存在这种转换。

6) 标准输入文件 stdin（键盘）、标准输出文件 stdout（显示器）、标准错误文件 stderr（显示器）是由系统打开的，可直接使用。

#### 二进制文件和文本文件的区别

从物理上讲二进制文件和字符文件没有区别，都是以二进制的形式保存在磁盘上。但是它们在文件的组织形式上不一样，二进制文件有文件头(File Header)，用以表明文件的大小、类型等信息，程序在处理二进制文件时一般会先分析文件头，判断文件是否合法，也就是说，文件头后面的数据才是程序真正要处理的；字符文件没有文件头，第一个字节就是要显示的内容。

字符文件是通用的，任何程序只要按照对应的编码方式打开都可以正确显示，二进制文件只有特定的程序才能处理。

另外，以文本方式打开时，遇到结束符`CTRLZ(0x1A)`就认为文件已经结束。所以，若使用文本方式打开二进制文件，就很容易出现文件读不完整，或內容不对的错误。即使是用文本方式打开文本文件，也要谨慎使用，比如复制文件，就不应该使用文本方式。

#### 文件读取

EOF 是 end of file 的缩写，表示文件末尾，是在 stdio.h 中定义的宏，它的值是一个负数，往往是 -1。返回值类型之所以为 int，就是为了容纳这个负数（char不能是负数）。

##### 以字符形式读写

```c
int fgetc (FILE *fp);
```

在文件内部有一个位置指针，用来指向当前读写到的位置，也就是读写到第几个字节。在文件打开时，该指针总是指向文件的第一个字节。使用fgetc 函数后，该指针会向后移动一个字节，所以可以连续多次使用fgetc读取多个字符。

EOF 本来表示文件末尾，意味着读取结束，但是很多函数在读取出错时也返回 EOF，那么当返回EOF时，到底是文件读取完毕了还是读取出错了？我们可以借助 stdio.h 中的两个函数来判断，分别是 feof() 和 ferror()。

```c
int fputc ( int ch, FILE *fp );
```

每写入一个字符，文件内部位置指针向后移动一个字节。

##### 以字符串形式读写

```c
char *fgets ( char *str, int n, FILE *fp );
```

注意，读取到的字符串会在末尾自动添加 '\0'，n 个字符也包括 '\0'。也就是说，实际只读取到了 n-1 个字符，如果希望读取 100 个字符，n 的值应该为 101。

```c
int fputs( char *str, FILE *fp );
```

##### 以数据块形式读写

```c
size_t fread ( void *ptr, size_t size, size_t count, FILE *fp );
```

```c
size_t fwrite ( void * ptr, size_t size, size_t count, FILE *fp );
```

fwrite()/fread() 函数直接操作字节，建议使用二进制方式打开文件。

##### 随机读写

实现随机读写的关键是要按要求移动位置指针，这称为文件的定位。

文件位置指针决定了读写文件的位置，`fseek` `rewind` `fsetpos` `freopen` 这几个函数可以改变文件的位置指针。

值得说明的是，fseek() 一般用于二进制文件，在文本文件中由于要进行转换，计算的位置有时会出错。

假设文件 “file” 的初始内容是：`This is one line.`

执行下面的代码：

```c
#include <stdio.h>
#include <unistd.h>

int main()
{
    FILE *fp;
    int c;

    fp = fopen("file", "rb+");
    if (fp == NULL) {
        puts("Error opening file.");
        return -1;
    }

    while ((c = fgetc(fp)) != EOF) {
        printf("%c", c);
        fflush(stdout);
        fputc('!', fp);
        sleep(1);
    }

    fclose(fp);

    return 0;
}
```

文件 “file” 的内容最后变为：`T!i! !s!o!e!l!n!.!`。

这是由于 `fgetc` `fputc` 都移动了文件的位置指针。

##### 获取文件大小

ftell() 函数用来获取文件内部指针（位置指针）距离文件开头的字节数，它的原型为：

```
long int ftell ( FILE * fp );
```

注意：fp 要以二进制方式打开，如果以文本方式打开，函数的返回值可能没有意义。

```c
long fsize(FILE *fp){
    long n;
    fpos_t fpos;  //当前位置
    fgetpos(fp, &fpos);  //获取当前位置
    fseek(fp, 0, SEEK_END);
    n = ftell(fp);
    fsetpos(fp,&fpos);  //恢复之前的位置
    return n;

```

##### 关于并发读写文件



