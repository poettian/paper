需要注意的是，虽然变量名、函数名、字符串名和数组名在本质上是一样的，它们都是地址的助记符，但在编写代码的过程中，我们认为变量名表示的是数据本身，而函数名、字符串名和数组名表示的是代码块或数据块的首地址。

C语言有两种表示字符串的方法，一种是字符数组，另一种是字符串常量，它们在内存中的存储位置不同，使得字符数组可以读取和修改，而字符串常量只能读取不能修改。

用指针变量作函数参数可以将函数外部的地址传递到函数内部，使得在函数内部可以操作函数外部的数据，并且这些数据不会随着函数的结束而被销毁。

前面我们说函数运行结束后会销毁所有的局部数据，这个观点并没错，大部分C语言教材也都强调了这一点。但是，这里所谓的销毁并不是将局部数据所占用的内存全部抹掉，而是程序放弃对它的使用权限，弃之不理，后面的代码可以随意使用这块内存。对于上面的两个例子，func() 运行结束后 n 的内存依然保持原样，值还是 100，如果使用及时也能够得到正确的数据，如果有其它函数被调用就会覆盖这块内存，得到的数据就失去了意义。

#### 空指针 NULL  和 void 指针

##### 空指针 NULL

NULL 是“零值、等于零”的意思，在C语言中表示空指针。从表面上理解，空指针是不指向任何数据的指针，是无效指针，程序使用它不会产生效果。

其实，NULL 是在`stdio.h`中定义的一个宏，它的具体内容为：

`#define NULL ((void *)0)`

`(void *)0`表示把数值 0 强制转换为`void *`类型，最外层的`( )`把宏定义的内容括起来，防止发生歧义。从整体上来看，NULL 指向了地址为 0 的内存，而不是前面说的不指向任何数据。

在进程的虚拟地址空间中，最低地址处有一段内存区域被称为保留区，这个区域不存储有效数据，也不能被用户程序访问，将 NULL 指向这块区域很容易检测到违规指针。

关于虚拟地址空间的概念以及程序的内存分布，我们将在《[C语言和内存](http://c.biancheng.net/cpp/u/c20/)》专题中深入讲解，现在读者只需要记住，在大多数操作系统中，极小的地址通常不保存数据，也不允许程序访问，NULL 可以指向这段地址区间中的任何一个地址。

##### void 指针

表示指针指向的数据的类型是未知的。

也就是说，`void *`表示一个有效指针，它确实指向实实在在的数据，只是数据的类型尚未确定，在后续使用过程中一般要进行强制类型转换。

#### 数组和指针

数组是一系列数据的集合，没有开始和结束标志，p 仅仅是一个指向 int 类型的指针，编译器不知道它指向的是一个整数还是一堆整数，对 p 使用 sizeof 求得的是指针变量本身的长度。也就是说，编译器并没有把 p 和数组关联起来，p 仅仅是一个指针变量，不管它指向哪里，sizeof 求得的永远是它本身所占用的字节数。

站在编译器的角度讲，变量名、数组名都是一种符号，它们最终都要和数据绑定起来。变量名用来指代一份数据，数组名用来指代一组数据（数据集合），它们都是有类型的，以便推断出所指代的数据的长度。

对，数组也有类型，这是很多读者没有意识到的，大部分C语言书籍对这一点也含糊其辞！我们可以将 int、float、char 等理解为基本类型，将数组理解为由基本类型派生得到的稍微复杂一些的类型。sizeof 就是根据符号的类型来计算长度的。

对于数组 a，它的类型是`int [6]`，表示这是一个拥有 6 个 int 数据的集合，1 个 int 的长度为 4，6 个 int 的长度为 4×6 = 24，sizeof 很容易求得。

对于指针变量 p，它的类型是`int *`，在 32 位环境下长度为 4，在 64 位环境下长度为 8。

归根结底，a 和 p 这两个符号的类型不同，指代的数据也不同，它们不是一码事，sizeof 是根据符号类型来求长度的，a 和 p 的类型不同，求得的长度自然也不一样。

对于二维数组，也是类似的道理，例如`int a[3][3]={1, 2, 3, 4, 5, 6, 7, 8, 9};`，它的类型是`int [3][3]`，长度是 4×3×3 = 36，读者可以亲自测试。

**编译器在编译过程中会创建一张专门的表格用来保存名字以及名字对应的数据类型、地址、作用域等信息，sizeof 是一个操作符，不是函数，使用 sizeof 时可以从这张表格中查询到符号的长度。**

#### 关于数组和指针可交换性的总结

C语言标准规定，当数组名作为数组定义的标识符（也就是定义或声明数组时）、sizeof 或 & 的操作数时，它才表示整个数组本身，在其他的表达式中，数组名会被转换为指向第 0 个元素的指针（地址）。

1) 用 a[i] 这样的形式对数组进行访问总是会被编译器改写成（或者说解释为）像 *(a+i) 这样的指针形式。

2) 指针始终是指针，它绝不可以改写成数组。你可以用下标形式访问指针，一般都是指针作为函数参数时，而且你知道实际传递给函数的是一个数组。

3) 在特定的环境中，也就是数组作为函数形参，也只有这种情况，一个数组可以看做是一个指针。作为函数形参的数组始终会被编译器修改成指向数组第一个元素的指针。

3) 当希望向函数传递数组时，可以把函数参数定义为数组形式（可以指定长度也可以不指定长度），也可以定义为指针。不管哪种形式，在函数内部都要作为指针变量对待。

#### 指针和二维数组

```c
int (*p)[4] = a; // 指向一维数组的指针，p 指向的数据类型是int [4]，那么p+1就前进 4×4 = 16 个字节，p-1就后退 16 个字节
int *p[4]; // 指针数组
```

#### 指向函数的指针

一个函数总是占用一段连续的内存区域，函数名在表达式中有时也会被转换为该函数所在内存区域的首地址，这和数组名非常类似。我们可以把函数的这个首地址（或称入口地址）赋予一个指针变量，使指针变量指向函数所在的内存区域，然后通过指针变量就可以找到并调用该函数。这种指针就是函数指针。

```c
returnType (*pointerName)(param list); 
// 形式有点类似于数组指针
// 参数列表中可以同时给出参数的类型和名称，也可以只给出参数的类型，省略参数的名称，这一点和函数原型非常类似。
```

#### 指针的写法

C语言标准规定，对于一个符号的定义，编译器总是从它的名字开始读取，然后按照优先级顺序依次解析。对，从名字开始，不是从开头也不是从末尾，这是理解复杂指针的关键！

```c
char *(* c[10])(int **p); // c 是一个拥有 10 个元素的指针数组，每个指针指向一个原型为char *func(int **p);的函数
```

```c
int (*(*(*pfunc)(int *))[5])(int *); //pfunc 是一个函数指针（蓝色部分），该函数的返回值是一个指针，它指向一个指针数组（红色部分），指针数组中的指针指向原型为int func(int *);的函数（橘黄色部分）。
```

#### main函数

```c
int main();
int main(int argc, char *argv[]);
```

