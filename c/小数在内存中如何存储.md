#### 概念

**浮点数**是数字（或者说数值）在内存中的一种存储格式，它和定点数是相对的。

这种以**指数**的形式来存储小数的解决方案就叫做浮点数。

C语言标准规定，小数在内存中以科学计数法的形式来存储，具体形式为：

![image-20200216181420992](/Users/tianzhiwei/Library/Application Support/typora-user-images/image-20200216181420992.png)

#### 转换

基数 base 已经确定是二进制了，就不用在内存中体现出来了，这样只需要在内存中存储符号 sign、尾数 mantissa、指数 exponent 这三个不确定的元素就可以了。

仍然以 19.625 为例，将它转换成二进制形式的浮点数格式：

`19.625 = 1.0011101×2^4`

此时符号 sign 为 0，尾数 mantissa 为 1.0011101，指数 exponent 为 4。

其中，尾数部分小数点前的1不需要在内存中体现出来。

#### 存储

float 和 double 的存储格式：

![image-20200216182320611](/Users/tianzhiwei/Library/Application Support/typora-user-images/image-20200216182320611.png)

float 的指数部分占用 8 Bits，能表示从 0~255 的值，取其中间值 127，指数在写入内存前先加上127，读取时再减去127，正数负数就显而易见了。19.625 转换后的指数为 4，4+127 = 131，131 换算成二进制为 1000 0011，这就是 19.626 的指数部分在 float 中的最终存储形式。

对于 float，中间值为 28-1 - 1 = 127；对于 double，中间值为 211-1 -1 = 1023。

#### 结论

对于 19.625，此时符号为 0；尾数为 1.0011101，截掉整数部分后为 0011101，补齐到 23 Bits 后为 001 1101 0000 0000 0000 0000；指数为 4，4+127 = 131，131 换算成二进制为 1000 0011。

所以，float 值 19.625 在内存中的值为：0 - 10000011 - 001 1101 0000 0000 0000 0000。

#### 精度问题

**原因**：有些十进制数字的尾数部分不能用二进制来精确的表达，只能是一个近似数。

对于 float，尾数部分有 23 位，再加上一个隐含的整数 1，一共是 24 位。最后一位可能是精确数字，也可能是近似数字（由四舍五入、向零舍入等不同方式得到）；除此以外，剩余的23位都是精确数字。从二进制的角度看，这种浮点格式的小数，最多有 24 位有效数字，但是能保证的是 23 位；也就是说，整体的精度为 23~24 位。如果转换成十进制，224 = 16 777 216，一共8位；也就是说，最多有 8 位有效数字，但是能保证的是 7 位，从而得出整体精度为 7~8 位。

对于 double，同理可得，二进制形式的精度为 52~53 位，十进制形式的精度为 15~16 位。

#### 特殊值

##### 特殊值

当指数 exp 的所有位都为 1 时，不再作为“正常”的浮点数对待，而是作为特殊值处理：

- 如果此时尾数 mant 的二进制位都为 0，则表示无穷大：
  - 如果符号 sign 为 1，则表示负无穷大；
  - 如果符号 sign 为 0，则表示正无穷大。
- 如果此时尾数 mant 的二进制位不全为 0，则表示 NaN（Not a Number），也即这是一个无效的数字，或者该数字未经初始化。

##### 非规格化浮点数

当指数 exp 的所有二进制位都为 0 时：

```c
mantissa = 0.mant
exponent = 1 - exp
```

对于非规格化浮点数，当尾数 mant 的所有二进制位都为 0 时，整个浮点数的值就为 0：

- 如果符号 sign 为 0，则表示 +0；
- 如果符号 sign 为 1，则表示 -0。

**0值**：0

**最小值**：2^-149

**最大值**：1.11...11 × 2^-127

##### 规格化浮点数（正常的浮点数）

**最小值**：1.0 × 2^-126

**最大值**：1.11...11 × 2^127

#### 总结

与定点数相比，浮点数在精度方面损失不小，但是在取值范围方面增大很多。牺牲精度，换来取值范围，这就是浮点数的整体思想。