结构体和结构体变量是两个不同的概念：结构体是一种数据类型，是一种创建变量的模板，编译器不会为它分配内存空间，就像 int、float、char 这些关键字本身不占用内存一样；结构体变量才包含实实在在的数据，才需要内存来存储。

结构体变量名和数组名不同，数组名在表达式中会被转换为数组指针，而结构体变量名不会，无论在任何表达式中它表示的都是整个集合本身，要想取得结构体变量的地址，必须在前面加`&`。

#### 枚举

```c
enum typeName{ valueName1, valueName2, valueName3, ...... };
```

枚举值默认从 0 开始，往后逐个加 1（递增）；

```c
enum week{ Mon = 1, Tues = 2, Wed = 3, Thurs = 4, Fri = 5, Sat = 6, Sun = 7 };

// 这样枚举值就从 1 开始递增，跟上面的写法是等效的。
enum week{ Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun };
```

枚举是一种类型，通过它可以定义枚举变量：

```c
enum week a, b, c;
```

有了枚举变量，就可以把列表中的值赋给它：

```c
enum week a = Mon, b = Wed, c = Sat;
```

需要注意的两点是：
1) 枚举列表中的 Mon、Tues、Wed 这些标识符的作用范围是全局的（严格来说是 main() 函数内部），不能再定义与它们名字相同的变量。

2) Mon、Tues、Wed 等都是常量，不能对它们赋值，只能将它们的值赋给其他的变量。

枚举和宏其实非常类似：宏在预处理阶段将名字替换成对应的值，枚举在编译阶段将名字替换成对应的值。我们可以将枚举理解为编译阶段的宏。这意味着，Mon、Tues、Wed 等都不是变量（但是 a 仍然是一个变量），它们不占用数据区（常量区、全局数据区、栈区和堆区）的内存，而是直接被编译到命令里面，放到代码区，所以不能用`&`取得它们的地址。这就是枚举的本质。

#### 共用体

结构体占用的内存大于等于所有成员占用的内存的总和（成员之间可能会存在缝隙），共用体占用的内存等于最长的成员占用的内存。共用体使用了内存覆盖技术，同一时刻只能保存一个成员的值，如果对新的成员赋值，就会把原来成员的值覆盖掉。

#### 大小端

大端和小端是指数据在内存中的存储模式，它由 CPU 决定：

1) 大端模式（Big-endian）是指将数据的低位（比如 1234 中的 34 就是低位）放在内存的高地址上，而数据的高位（比如 1234 中的 12 就是高位）放在内存的低地址上。

2) 小端模式（Little-endian）是指将数据的低位放在内存的低地址上，而数据的高位放在内存的高地址上。

我们的 PC 机上使用的是 X86 结构的 CPU，它是小端模式；51 单片机是大端模式；很多 ARM、DSP 也是小端模式（部分 ARM 处理器还可以由硬件来选择是大端模式还是小端模式）。



借用共用体，检测大小端：

```c
#include <stdio.h>
int main(){
    union{
        int n;
        char ch;
    } data;
    data.n = 0x00000001;  //也可以直接写作 data.n = 1;
    if(data.ch == 1){
        printf("Little-endian\n");
    }else{
        printf("Big-endian\n");
    }
    return 0;
}
```

#### 位域

在结构体定义时，我们可以指定某个成员变量所占用的二进制位数（Bit），这就是位域。

```c
struct bs{
    unsigned m;
    unsigned n: 4;
    unsigned char ch: 6;
}
```

C语言标准规定，位域的宽度不能超过它所依附的数据类型的长度。通俗地讲，成员变量都是有类型的，这个类型限制了成员变量的最大长度，`:`后面的数字不能超过这个长度。

C语言标准还规定，只有有限的几种数据类型可以用于位域。在 ANSI C 中，这几种数据类型是 int、signed int 和 unsigned int（int 默认就是 signed int）；到了 C99，_Bool 也被支持了。但编译器在具体实现时都进行了扩展，额外支持了 char、signed char、unsigned char 以及 enum 类型，所以上面的代码虽然不符合C语言标准，但它依然能够被编译器支持。

通过上面的分析，我们发现位域成员往往不占用完整的字节，有时候也不处于字节的开头位置，因此使用`&`获取位域成员的地址是没有意义的，C语言也禁止这样做。**地址是字节（Byte）的编号，而不是位（Bit）的编号。**

#### 关于 typedef（很重要）

`typedef` 和 `定义指针` 在用法上很像：

```c
int (*pr)[4]; // pr 是指向 int [4] 类型的指针

typedef int (*PTR_TO_ARR)[4]; // PRT_TO_ARR 代表指针类型，这个指针指向 int [4] 类型
```

需要强调的是，typedef 是赋予现有类型一个新的名字，而不是创建新的类型。为了“见名知意”，请尽量使用含义明确的标识符，并且尽量大写。

#### 关于const

由于常量一旦被创建后其值就不能再改变，所以常量必须在定义的同时赋值（初始化），后面的任何赋值行为都将引发错误。

##### const 和 指针

const 可以和指针变量一起使用，这样可以限制指针变量本身，也可以限制指针指向的数据。

```c
// 指针所指向的数据是只读的，也就是 p1、p2 本身的值可以修改（指向不同的数据），但它们指向的数据不能被修改。
const int *p1;  
int const *p2;

// 指针是只读的，也就是 p3 本身的值不能被修改；
int * const p3; 


// 指针本身和它指向的数据都是只读的
const int * const p4;
int const * const p5;
```

##### const 和 函数形参

const 通常用在函数形参中，如果形参是一个指针，为了防止在函数内部修改指针指向的数据，就可以用 const 来限制。

