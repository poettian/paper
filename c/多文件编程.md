#### 编译过程

事实上，从源代码生成可执行文件可以分为四个步骤，分别是预处理（Preprocessing）、编译（Compilation）、汇编（Assembly）和链接（Linking）。

下图是 GCC 生成 a.out 的过程：
![img](http://c.biancheng.net/cpp/uploads/allimg/160616/1-160616105430F4.jpg)

#### 目标文件和可执行文件的组织形式

需要明确的是：编译是针对单个源文件的，有几个源文件就会生成几个目标文件，并且在生成过程中不受其他源文件的影响。也就是说，不管当前工程中有多少个源文件，编译器每次只编译一个源文件、生成一个目标文件。

另外，动态链接库（DLL，Dynamic Linking Library）（Windows 下的`.dll`和 Linux 下的`.so`）和静态链接库（Static Linking Library）（Windows 下的`.lib`和 Linux 下的`.a`）也是按照可执行文件的格式存储的。

静态链接库稍有不同，它是把多个目标文件捆绑在一起形成一个文件，再加上一些索引，你可以简单地把它理解为一个包含了很多目标文件的包。

有点复杂，回头看：[目标文件和可执行文件里有什么](http://c.biancheng.net/cpp/html/3235.html)。

#### 关于链接

链接（Linking）就是通过符号将各个模块组合成一个独立的程序的过程。

这种在程序运行之前确定符号地址的过程叫做静态链接（Static Linking）；如果需要等到程序运行期间再确定符号地址，就叫做动态链接（Dynamic Linking）。

总结起来，链接的一项重要任务就是确定函数和全局变量的地址，并对每一个重定位入口进行修正。

#### 强符号、弱符号、强引用、弱引用

#### 头文件

当使用相对路径的方式引入头文件时，如果使用`< >`，那么“相对”的就是系统路径，也就是说，编译器会直接在这些系统路径下查找头文件；如果使用`" "`，那么首先“相对”的是当前路径，然后“相对”的才是系统路径，也就是说，编译器首先在当前路径下查找头文件，找不到的话才会继续在系统路径下查找。

而使用绝对路径的方式引入头文件时，< >和" "没有任何区别，因为头文件路径已经写死了（从根部开始查找），不需要“相对”任何路径。

防止重复包含：

```c
#ifndef _XYZ_H
#define _XYZ_H
/* 头文件内容 */
#endif
```

