#### 概念

并发编程的常见实现：

* 多进程
* 多线程
* 基于回调的非阻塞/异步io
* 协程

##### Go 的协程间通信

在 Go 语言并发编程实践中，使用的都是基于消息传递的方式实现协程之间的通信。

在消息传递机制中，每个协程是独立的个体，并且都有自己的变量，与共享内存不同的是，在不同协程间这些变量不共享，每个协程的输入和输出都只有一种方式，那就是消息，这有点类似于进程：每个进程都是独立的，不会被其他进程打扰，不同进程间靠消息来通信，它们不会共享内存。

通道是 Go 语言在语言级别提供的协程通信方式，它是一种**数据类型**，本身是并发安全的，我们可以使用它在多个 goroutine 之间传递消息，而不必担心通道中的值被污染。

> 注：需要注意的是，通道是进程内的通信方式，因此通过通道传递对象的过程和调用函数时的参数传递行为比较一致，也可以传递指针。如果需要跨进程通信，建议通过分布式系统的方法来解决，比如使用 Socket 或者 HTTP 等通信协议，Go 语言对于网络方面也有非常完善的支持，学院君会在介绍完并发编程后介绍网络通信。

通道是一种数据类型，和数组/切片类型类似，一个通道只能传递一种类型的值，这个类型需要在声明 通道时指定。在使用通道时，需要通过 `make` 进行声明，通道对应的类型关键字是 `chan`：

```go
ch := make(chan int)
```

可以把通道看作是一个先进先出（FIFO）的队列，通道中的元素会严格按照发送顺序排列，继而按照排列顺序被接收，通道元素的发送和接收都可以通过 `<-` 操作符来实现，发送时元素值在右，通道变量在左：

```go
ch <- 1  // 表示把元素 1 发送到通道 ch
```

接收时通道变量在右，可以通过指定变量接收元素值：

```go
element := <-ch
```

也可以留空表示忽略：

```go
<-ch
```

之所以通道可以实现和「共享内存+锁」一样的效果，是因为往通道写入数据和从通道接收数据都是原子操作，或者说是同步阻塞的，当我们向某个通道写入数据时，就相当于该通道被加锁，直到写入操作完成才能执行从该通道读取数据的操作，反过来，当我们从某个通道读取数据时，其他协程也不能操作该通道，直到读取完成，如果通道中没有数据，则会阻塞在这里，直到通道被写入数据。因此，可以看到通道的发送和接收操作是互斥的，同一时间同一个进程内的所有协程对某个通道只能执行发送或接收操作，两者不可能同时进行，这样就保证了并发的安全性，数据不可能被污染。

信道与文件不同，通常情况下无需关闭它们。只有在必须告诉接收者不再有需要发送的值时才有必要关闭，例如终止一个 `range` 循环。

接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭：若没有值可以接收且信道已被关闭，那么在执行完：

```go
v, ok := <-ch
```

之后 `ok` 会被设置为 `false`。

#### 详解通道

##### 声明和初始化

与其他数据类型不同，通道类型变量除了声明通道类型本身外，还要声明通道中传递数据的类型。

通道也是引用类型（和切片、字典一样），所以可以通过 `make` 函数进行初始化，在通过 `make` 函数初始化通道时，还可以传递第二个参数，表示通道的容量：

```go
ch := make(chan int, 10)
```

第二个参数是可选的，用于指定通道最多可以缓存多少个元素，默认值是 0，此时通道可以被称作非缓冲通道，表示往通道中发送一个元素后，只有该元素被接收后才能存入下一个元素，与之相对的，当缓存值大于 0 时，通道可以称作缓冲通道，即使通道元素没有被接收，也可以继续往里面发送元素，直到超过缓冲值，显然设置这个缓冲值可以提高通道的操作效率。

当我们将数据发送到通道时，发送的是数据的副本，同理，从通道中接收数据时，接收的也是数据的副本。

##### 单向通道

当我们将一个通道类型变量传递到一个函数时（通常是在另外一个协程中执行），如果这个函数只能发送数据到通道，可以通过如下将其指定为单向只写通道（发送通道）：

```go
func test(ch chan<- int)
```

如果我们将一个通道类型变量传递到一个只允许从该通道读取数据的函数，可以通过如下方式将通道指定为单向只读通道（接收通道）：

```go
func test(ch <-chan int)
```

单向通道的初始化和双向通道一样：

```go
ch1 := make(chan int)
ch2 := make(chan<- int)
ch3 := make(<-chan int)
```

我们还可以通过如下方式实现双向通道和单向通道的转化：

```go
ch1 := make(chan int) 
ch2 := <-chan int(ch1)
ch3 := chan<- int(ch1)
```

基于双向通道 `ch1`，我们通过类型转化初始化了两个单向通道：单向只读的 `ch2` 和单向只写的 `ch3`。注意这个转化是不可逆的，双向通道可以转化为任意类型的单向通道，但单向通道不能转化为双向通道，读写通道之间也不能相互转化。

实际上，我们在将双向通道传递到限定通道参数操作类型的函数时，就应用到了类型转化。

##### select 语句等待通道就绪

```go
select { 
    case <-chan1:
        // 如果从 chan1 通道成功接收数据，则执行该分支代码
    case chan2 <- 1:
        // 如果成功向 chan2 通道成功发送数据，则执行该分支代码 
    default:
        // 如果上面都没有成功，则进入 default 分支处理流程 
}
```

`select` 不像 `switch`，`case` 后面并不带判断条件，而是直接去查看 `case` 语句，每个 `case` 语句都必须是一个面向通道的操作，比如上面的示例代码中，第一个 `case` 试图从 `chan1` 接收数据并直接忽略读到的数据，第二个 `case` 试图向 `chan2` 通道发送一个整型数据 `1`，需要注意的是这两个 `case` 的执行不是 `if...else...` 那种先后关系，而是会并发执行，然后 `select` 会选择先操作成功返回的那个 `case` 分支去执行，如果两者同时返回，则随机选择一个执行，如果这两者都没有返回，则进入 `default` 分支，这里也不会出现阻塞，如果 `chan1` 通道为空，或者 `chan2` 通道已满，就会立即进入 `default` 分支，但是如果没有 `default` 语句，则会阻塞直到某个通道操作成功。

但这时要注意，简单地在 `select` 语句的分支中使用 `break` 语句，只能结束当前的 `select` 语句的执行，而并不会对外层的 `for` 语句产生作用，如果 `for` 循环本身没有退出机制的话会无休止地运行下去。

##### 两个例子

避免超时处理：

```go
package main

import (
    "fmt"
    "time"
)

func main()  {
    // 初始化 ch 通道
    ch := make(chan int, 1)

    // 初始化 timeout 通道
    timeout := make(chan bool, 1)

    // 实现一个匿名超时等待函数
    go func() {
        time.Sleep(1e9)  // 睡眠1秒钟
        timeout <- true
    }()

    // 借助 timeout 通道结合 select 语句实现 ch 通道读取超时效果
    select {
        case <- ch:
            fmt.Println("接收到 ch 通道数据")
        case <- timeout:
            fmt.Println("超时1秒，程序退出")
    }
}
```

避免对已关闭通道进行操作：

```go
package main

import "fmt"

func main()  {
    ch := make(chan int, 2)
    // 发送方
    go func() {
        for i := 0; i < 5; i++ {
            fmt.Printf("发送方: 发送数据 %v...\n", i)
            ch <- i
        }
        fmt.Println("发送方: 关闭通道...")
        close(ch)
    }()
    // 接收方
    for {
        num, ok := <-ch
        if !ok {
            fmt.Println("接收方: 通道已关闭")
            break
        }
        fmt.Printf("接收方: 接收数据: %v\n", num)
    }
    fmt.Println("程序退出")
}
```

