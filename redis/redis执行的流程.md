**步骤一：用户输入一条命令**

**步骤二：客户端先将命令转换成 Redis 协议，然后再通过 socket 连接发送给服务器端**

- 与服务器端以 socket 和 I/O 多路复用的技术建立链接；
- 将命令转换为 Redis 通讯协议，再将这些协议发送至缓冲区。

**步骤三：服务器端接收到命令**

**步骤四：执行前准备**

① 判断是否为退出命令，如果是则直接返回；

② 非 null 判断，检查 client 对象是否为 null，如果是返回错误信息；

③ 获取执行命令，根据 client 对象存储的属性信息去 redisCommand 结构中查询执行命令；

④ 用户权限效验，未通过身份验证的客户端只能执行 AUTH(授权) 命令，未通过身份验证的客户端执行了 AUTH 之外的命令则返回错误信息；

⑤ 集群相关操作，如果是集群模式，把命令重定向到目标节点，如果是 master(主节点) 则不需要重定向；

⑥ 检查服务器端最大内存限制，如果服务器端开启了最大内存限制，会先检查内存大小，如果内存超过了最大值会对内存进行回收操作；

⑦ 持久化检测，检查服务器是否开启了持久化和持久化出错停止写入配置，如果开启了此配置并且有持久化失败的情况，禁止执行写命令；

⑧ 集群模式最少从节点(slave)验证，如果是集群模式并且配置了 repl*min*slaves*to*write(最小从节点写入)，当从节点的数量少于配置项时，禁止执行写命令；

⑨ 只读从节点验证，当此服务器为只读从节点时，只接受 master 的写命令；

⑩ 客户端订阅判断，当客户端正在订阅频道时，只会执行部分命令（只会执行 SUBSCRIBE、PSUBSCRIBE、UNSUBSCRIBE、PUNSUBSCRIBE，其他命令都会被拒绝）。

⑪ 从节点状态效验，当服务器为 slave 并且没有连接 master 时，只会执行状态查询相关的命令，如 info 等；

⑫ 服务器初始化效验，当服务器正在启动时，只会执行 loading 标志的命令，其他的命令都会被拒绝；

⑬ lua 脚本阻塞效验，当服务器因为执行 lua 脚本阻塞时，只会执行部分命令；

⑭ 事务命令效验，如果执行的是事务命令，则开启事务把命令放入等待队列；

⑮ 监视器 (monitor) 判断，如果服务器打开了监视器功能，那么服务器也会把执行命令和相关参数发送给监视器 (监视器是用于监控服务器运行状态的)。

**步骤五：执行最终命令，调用 redisCommand 中的 proc 函数执行命令。**

**步骤六：执行完后相关记录和统计**

慢查询统计、持久化、复制

**步骤七：返回结果给客户端**

